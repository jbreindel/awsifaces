// Code generated by mockery v2.42.1. DO NOT EDIT.

package mocks

import (
	context "context"

	backupstorage "github.com/aws/aws-sdk-go-v2/service/backupstorage"

	mock "github.com/stretchr/testify/mock"
)

// BackupstorageClient is an autogenerated mock type for the BackupstorageClient type
type BackupstorageClient struct {
	mock.Mock
}

// DeleteObject provides a mock function with given fields: ctx, params, optFns
func (_m *BackupstorageClient) DeleteObject(ctx context.Context, params *backupstorage.DeleteObjectInput, optFns ...func(*backupstorage.Options)) (*backupstorage.DeleteObjectOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteObject")
	}

	var r0 *backupstorage.DeleteObjectOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *backupstorage.DeleteObjectInput, ...func(*backupstorage.Options)) (*backupstorage.DeleteObjectOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *backupstorage.DeleteObjectInput, ...func(*backupstorage.Options)) *backupstorage.DeleteObjectOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*backupstorage.DeleteObjectOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *backupstorage.DeleteObjectInput, ...func(*backupstorage.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetChunk provides a mock function with given fields: ctx, params, optFns
func (_m *BackupstorageClient) GetChunk(ctx context.Context, params *backupstorage.GetChunkInput, optFns ...func(*backupstorage.Options)) (*backupstorage.GetChunkOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetChunk")
	}

	var r0 *backupstorage.GetChunkOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *backupstorage.GetChunkInput, ...func(*backupstorage.Options)) (*backupstorage.GetChunkOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *backupstorage.GetChunkInput, ...func(*backupstorage.Options)) *backupstorage.GetChunkOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*backupstorage.GetChunkOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *backupstorage.GetChunkInput, ...func(*backupstorage.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetObjectMetadata provides a mock function with given fields: ctx, params, optFns
func (_m *BackupstorageClient) GetObjectMetadata(ctx context.Context, params *backupstorage.GetObjectMetadataInput, optFns ...func(*backupstorage.Options)) (*backupstorage.GetObjectMetadataOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetObjectMetadata")
	}

	var r0 *backupstorage.GetObjectMetadataOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *backupstorage.GetObjectMetadataInput, ...func(*backupstorage.Options)) (*backupstorage.GetObjectMetadataOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *backupstorage.GetObjectMetadataInput, ...func(*backupstorage.Options)) *backupstorage.GetObjectMetadataOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*backupstorage.GetObjectMetadataOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *backupstorage.GetObjectMetadataInput, ...func(*backupstorage.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListChunks provides a mock function with given fields: ctx, params, optFns
func (_m *BackupstorageClient) ListChunks(ctx context.Context, params *backupstorage.ListChunksInput, optFns ...func(*backupstorage.Options)) (*backupstorage.ListChunksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListChunks")
	}

	var r0 *backupstorage.ListChunksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *backupstorage.ListChunksInput, ...func(*backupstorage.Options)) (*backupstorage.ListChunksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *backupstorage.ListChunksInput, ...func(*backupstorage.Options)) *backupstorage.ListChunksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*backupstorage.ListChunksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *backupstorage.ListChunksInput, ...func(*backupstorage.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListObjects provides a mock function with given fields: ctx, params, optFns
func (_m *BackupstorageClient) ListObjects(ctx context.Context, params *backupstorage.ListObjectsInput, optFns ...func(*backupstorage.Options)) (*backupstorage.ListObjectsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListObjects")
	}

	var r0 *backupstorage.ListObjectsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *backupstorage.ListObjectsInput, ...func(*backupstorage.Options)) (*backupstorage.ListObjectsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *backupstorage.ListObjectsInput, ...func(*backupstorage.Options)) *backupstorage.ListObjectsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*backupstorage.ListObjectsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *backupstorage.ListObjectsInput, ...func(*backupstorage.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NotifyObjectComplete provides a mock function with given fields: ctx, params, optFns
func (_m *BackupstorageClient) NotifyObjectComplete(ctx context.Context, params *backupstorage.NotifyObjectCompleteInput, optFns ...func(*backupstorage.Options)) (*backupstorage.NotifyObjectCompleteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NotifyObjectComplete")
	}

	var r0 *backupstorage.NotifyObjectCompleteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *backupstorage.NotifyObjectCompleteInput, ...func(*backupstorage.Options)) (*backupstorage.NotifyObjectCompleteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *backupstorage.NotifyObjectCompleteInput, ...func(*backupstorage.Options)) *backupstorage.NotifyObjectCompleteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*backupstorage.NotifyObjectCompleteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *backupstorage.NotifyObjectCompleteInput, ...func(*backupstorage.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *BackupstorageClient) Options() backupstorage.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 backupstorage.Options
	if rf, ok := ret.Get(0).(func() backupstorage.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(backupstorage.Options)
	}

	return r0
}

// PutChunk provides a mock function with given fields: ctx, params, optFns
func (_m *BackupstorageClient) PutChunk(ctx context.Context, params *backupstorage.PutChunkInput, optFns ...func(*backupstorage.Options)) (*backupstorage.PutChunkOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutChunk")
	}

	var r0 *backupstorage.PutChunkOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *backupstorage.PutChunkInput, ...func(*backupstorage.Options)) (*backupstorage.PutChunkOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *backupstorage.PutChunkInput, ...func(*backupstorage.Options)) *backupstorage.PutChunkOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*backupstorage.PutChunkOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *backupstorage.PutChunkInput, ...func(*backupstorage.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutObject provides a mock function with given fields: ctx, params, optFns
func (_m *BackupstorageClient) PutObject(ctx context.Context, params *backupstorage.PutObjectInput, optFns ...func(*backupstorage.Options)) (*backupstorage.PutObjectOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutObject")
	}

	var r0 *backupstorage.PutObjectOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *backupstorage.PutObjectInput, ...func(*backupstorage.Options)) (*backupstorage.PutObjectOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *backupstorage.PutObjectInput, ...func(*backupstorage.Options)) *backupstorage.PutObjectOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*backupstorage.PutObjectOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *backupstorage.PutObjectInput, ...func(*backupstorage.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartObject provides a mock function with given fields: ctx, params, optFns
func (_m *BackupstorageClient) StartObject(ctx context.Context, params *backupstorage.StartObjectInput, optFns ...func(*backupstorage.Options)) (*backupstorage.StartObjectOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartObject")
	}

	var r0 *backupstorage.StartObjectOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *backupstorage.StartObjectInput, ...func(*backupstorage.Options)) (*backupstorage.StartObjectOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *backupstorage.StartObjectInput, ...func(*backupstorage.Options)) *backupstorage.StartObjectOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*backupstorage.StartObjectOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *backupstorage.StartObjectInput, ...func(*backupstorage.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewBackupstorageClient creates a new instance of BackupstorageClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewBackupstorageClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *BackupstorageClient {
	mock := &BackupstorageClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
