// Code generated by mockery v2.42.1. DO NOT EDIT.

package mocks

import (
	context "context"

	bedrockagent "github.com/aws/aws-sdk-go-v2/service/bedrockagent"

	mock "github.com/stretchr/testify/mock"
)

// BedrockagentClient is an autogenerated mock type for the BedrockagentClient type
type BedrockagentClient struct {
	mock.Mock
}

// AssociateAgentKnowledgeBase provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) AssociateAgentKnowledgeBase(ctx context.Context, params *bedrockagent.AssociateAgentKnowledgeBaseInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.AssociateAgentKnowledgeBaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateAgentKnowledgeBase")
	}

	var r0 *bedrockagent.AssociateAgentKnowledgeBaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.AssociateAgentKnowledgeBaseInput, ...func(*bedrockagent.Options)) (*bedrockagent.AssociateAgentKnowledgeBaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.AssociateAgentKnowledgeBaseInput, ...func(*bedrockagent.Options)) *bedrockagent.AssociateAgentKnowledgeBaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.AssociateAgentKnowledgeBaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.AssociateAgentKnowledgeBaseInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAgent provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) CreateAgent(ctx context.Context, params *bedrockagent.CreateAgentInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.CreateAgentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAgent")
	}

	var r0 *bedrockagent.CreateAgentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.CreateAgentInput, ...func(*bedrockagent.Options)) (*bedrockagent.CreateAgentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.CreateAgentInput, ...func(*bedrockagent.Options)) *bedrockagent.CreateAgentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.CreateAgentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.CreateAgentInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAgentActionGroup provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) CreateAgentActionGroup(ctx context.Context, params *bedrockagent.CreateAgentActionGroupInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.CreateAgentActionGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAgentActionGroup")
	}

	var r0 *bedrockagent.CreateAgentActionGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.CreateAgentActionGroupInput, ...func(*bedrockagent.Options)) (*bedrockagent.CreateAgentActionGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.CreateAgentActionGroupInput, ...func(*bedrockagent.Options)) *bedrockagent.CreateAgentActionGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.CreateAgentActionGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.CreateAgentActionGroupInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAgentAlias provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) CreateAgentAlias(ctx context.Context, params *bedrockagent.CreateAgentAliasInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.CreateAgentAliasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAgentAlias")
	}

	var r0 *bedrockagent.CreateAgentAliasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.CreateAgentAliasInput, ...func(*bedrockagent.Options)) (*bedrockagent.CreateAgentAliasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.CreateAgentAliasInput, ...func(*bedrockagent.Options)) *bedrockagent.CreateAgentAliasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.CreateAgentAliasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.CreateAgentAliasInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDataSource provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) CreateDataSource(ctx context.Context, params *bedrockagent.CreateDataSourceInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.CreateDataSourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDataSource")
	}

	var r0 *bedrockagent.CreateDataSourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.CreateDataSourceInput, ...func(*bedrockagent.Options)) (*bedrockagent.CreateDataSourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.CreateDataSourceInput, ...func(*bedrockagent.Options)) *bedrockagent.CreateDataSourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.CreateDataSourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.CreateDataSourceInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateKnowledgeBase provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) CreateKnowledgeBase(ctx context.Context, params *bedrockagent.CreateKnowledgeBaseInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.CreateKnowledgeBaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateKnowledgeBase")
	}

	var r0 *bedrockagent.CreateKnowledgeBaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.CreateKnowledgeBaseInput, ...func(*bedrockagent.Options)) (*bedrockagent.CreateKnowledgeBaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.CreateKnowledgeBaseInput, ...func(*bedrockagent.Options)) *bedrockagent.CreateKnowledgeBaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.CreateKnowledgeBaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.CreateKnowledgeBaseInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAgent provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) DeleteAgent(ctx context.Context, params *bedrockagent.DeleteAgentInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.DeleteAgentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAgent")
	}

	var r0 *bedrockagent.DeleteAgentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.DeleteAgentInput, ...func(*bedrockagent.Options)) (*bedrockagent.DeleteAgentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.DeleteAgentInput, ...func(*bedrockagent.Options)) *bedrockagent.DeleteAgentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.DeleteAgentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.DeleteAgentInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAgentActionGroup provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) DeleteAgentActionGroup(ctx context.Context, params *bedrockagent.DeleteAgentActionGroupInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.DeleteAgentActionGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAgentActionGroup")
	}

	var r0 *bedrockagent.DeleteAgentActionGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.DeleteAgentActionGroupInput, ...func(*bedrockagent.Options)) (*bedrockagent.DeleteAgentActionGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.DeleteAgentActionGroupInput, ...func(*bedrockagent.Options)) *bedrockagent.DeleteAgentActionGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.DeleteAgentActionGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.DeleteAgentActionGroupInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAgentAlias provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) DeleteAgentAlias(ctx context.Context, params *bedrockagent.DeleteAgentAliasInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.DeleteAgentAliasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAgentAlias")
	}

	var r0 *bedrockagent.DeleteAgentAliasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.DeleteAgentAliasInput, ...func(*bedrockagent.Options)) (*bedrockagent.DeleteAgentAliasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.DeleteAgentAliasInput, ...func(*bedrockagent.Options)) *bedrockagent.DeleteAgentAliasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.DeleteAgentAliasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.DeleteAgentAliasInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAgentVersion provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) DeleteAgentVersion(ctx context.Context, params *bedrockagent.DeleteAgentVersionInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.DeleteAgentVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAgentVersion")
	}

	var r0 *bedrockagent.DeleteAgentVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.DeleteAgentVersionInput, ...func(*bedrockagent.Options)) (*bedrockagent.DeleteAgentVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.DeleteAgentVersionInput, ...func(*bedrockagent.Options)) *bedrockagent.DeleteAgentVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.DeleteAgentVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.DeleteAgentVersionInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteDataSource provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) DeleteDataSource(ctx context.Context, params *bedrockagent.DeleteDataSourceInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.DeleteDataSourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDataSource")
	}

	var r0 *bedrockagent.DeleteDataSourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.DeleteDataSourceInput, ...func(*bedrockagent.Options)) (*bedrockagent.DeleteDataSourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.DeleteDataSourceInput, ...func(*bedrockagent.Options)) *bedrockagent.DeleteDataSourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.DeleteDataSourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.DeleteDataSourceInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteKnowledgeBase provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) DeleteKnowledgeBase(ctx context.Context, params *bedrockagent.DeleteKnowledgeBaseInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.DeleteKnowledgeBaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteKnowledgeBase")
	}

	var r0 *bedrockagent.DeleteKnowledgeBaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.DeleteKnowledgeBaseInput, ...func(*bedrockagent.Options)) (*bedrockagent.DeleteKnowledgeBaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.DeleteKnowledgeBaseInput, ...func(*bedrockagent.Options)) *bedrockagent.DeleteKnowledgeBaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.DeleteKnowledgeBaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.DeleteKnowledgeBaseInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateAgentKnowledgeBase provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) DisassociateAgentKnowledgeBase(ctx context.Context, params *bedrockagent.DisassociateAgentKnowledgeBaseInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.DisassociateAgentKnowledgeBaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateAgentKnowledgeBase")
	}

	var r0 *bedrockagent.DisassociateAgentKnowledgeBaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.DisassociateAgentKnowledgeBaseInput, ...func(*bedrockagent.Options)) (*bedrockagent.DisassociateAgentKnowledgeBaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.DisassociateAgentKnowledgeBaseInput, ...func(*bedrockagent.Options)) *bedrockagent.DisassociateAgentKnowledgeBaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.DisassociateAgentKnowledgeBaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.DisassociateAgentKnowledgeBaseInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAgent provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) GetAgent(ctx context.Context, params *bedrockagent.GetAgentInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.GetAgentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAgent")
	}

	var r0 *bedrockagent.GetAgentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetAgentInput, ...func(*bedrockagent.Options)) (*bedrockagent.GetAgentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetAgentInput, ...func(*bedrockagent.Options)) *bedrockagent.GetAgentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.GetAgentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.GetAgentInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAgentActionGroup provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) GetAgentActionGroup(ctx context.Context, params *bedrockagent.GetAgentActionGroupInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.GetAgentActionGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAgentActionGroup")
	}

	var r0 *bedrockagent.GetAgentActionGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetAgentActionGroupInput, ...func(*bedrockagent.Options)) (*bedrockagent.GetAgentActionGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetAgentActionGroupInput, ...func(*bedrockagent.Options)) *bedrockagent.GetAgentActionGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.GetAgentActionGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.GetAgentActionGroupInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAgentAlias provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) GetAgentAlias(ctx context.Context, params *bedrockagent.GetAgentAliasInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.GetAgentAliasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAgentAlias")
	}

	var r0 *bedrockagent.GetAgentAliasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetAgentAliasInput, ...func(*bedrockagent.Options)) (*bedrockagent.GetAgentAliasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetAgentAliasInput, ...func(*bedrockagent.Options)) *bedrockagent.GetAgentAliasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.GetAgentAliasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.GetAgentAliasInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAgentKnowledgeBase provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) GetAgentKnowledgeBase(ctx context.Context, params *bedrockagent.GetAgentKnowledgeBaseInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.GetAgentKnowledgeBaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAgentKnowledgeBase")
	}

	var r0 *bedrockagent.GetAgentKnowledgeBaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetAgentKnowledgeBaseInput, ...func(*bedrockagent.Options)) (*bedrockagent.GetAgentKnowledgeBaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetAgentKnowledgeBaseInput, ...func(*bedrockagent.Options)) *bedrockagent.GetAgentKnowledgeBaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.GetAgentKnowledgeBaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.GetAgentKnowledgeBaseInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAgentVersion provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) GetAgentVersion(ctx context.Context, params *bedrockagent.GetAgentVersionInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.GetAgentVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAgentVersion")
	}

	var r0 *bedrockagent.GetAgentVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetAgentVersionInput, ...func(*bedrockagent.Options)) (*bedrockagent.GetAgentVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetAgentVersionInput, ...func(*bedrockagent.Options)) *bedrockagent.GetAgentVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.GetAgentVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.GetAgentVersionInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDataSource provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) GetDataSource(ctx context.Context, params *bedrockagent.GetDataSourceInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.GetDataSourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDataSource")
	}

	var r0 *bedrockagent.GetDataSourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetDataSourceInput, ...func(*bedrockagent.Options)) (*bedrockagent.GetDataSourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetDataSourceInput, ...func(*bedrockagent.Options)) *bedrockagent.GetDataSourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.GetDataSourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.GetDataSourceInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIngestionJob provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) GetIngestionJob(ctx context.Context, params *bedrockagent.GetIngestionJobInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.GetIngestionJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetIngestionJob")
	}

	var r0 *bedrockagent.GetIngestionJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetIngestionJobInput, ...func(*bedrockagent.Options)) (*bedrockagent.GetIngestionJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetIngestionJobInput, ...func(*bedrockagent.Options)) *bedrockagent.GetIngestionJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.GetIngestionJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.GetIngestionJobInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetKnowledgeBase provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) GetKnowledgeBase(ctx context.Context, params *bedrockagent.GetKnowledgeBaseInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.GetKnowledgeBaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetKnowledgeBase")
	}

	var r0 *bedrockagent.GetKnowledgeBaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetKnowledgeBaseInput, ...func(*bedrockagent.Options)) (*bedrockagent.GetKnowledgeBaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.GetKnowledgeBaseInput, ...func(*bedrockagent.Options)) *bedrockagent.GetKnowledgeBaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.GetKnowledgeBaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.GetKnowledgeBaseInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAgentActionGroups provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) ListAgentActionGroups(ctx context.Context, params *bedrockagent.ListAgentActionGroupsInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.ListAgentActionGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAgentActionGroups")
	}

	var r0 *bedrockagent.ListAgentActionGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListAgentActionGroupsInput, ...func(*bedrockagent.Options)) (*bedrockagent.ListAgentActionGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListAgentActionGroupsInput, ...func(*bedrockagent.Options)) *bedrockagent.ListAgentActionGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.ListAgentActionGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.ListAgentActionGroupsInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAgentAliases provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) ListAgentAliases(ctx context.Context, params *bedrockagent.ListAgentAliasesInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.ListAgentAliasesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAgentAliases")
	}

	var r0 *bedrockagent.ListAgentAliasesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListAgentAliasesInput, ...func(*bedrockagent.Options)) (*bedrockagent.ListAgentAliasesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListAgentAliasesInput, ...func(*bedrockagent.Options)) *bedrockagent.ListAgentAliasesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.ListAgentAliasesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.ListAgentAliasesInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAgentKnowledgeBases provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) ListAgentKnowledgeBases(ctx context.Context, params *bedrockagent.ListAgentKnowledgeBasesInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.ListAgentKnowledgeBasesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAgentKnowledgeBases")
	}

	var r0 *bedrockagent.ListAgentKnowledgeBasesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListAgentKnowledgeBasesInput, ...func(*bedrockagent.Options)) (*bedrockagent.ListAgentKnowledgeBasesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListAgentKnowledgeBasesInput, ...func(*bedrockagent.Options)) *bedrockagent.ListAgentKnowledgeBasesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.ListAgentKnowledgeBasesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.ListAgentKnowledgeBasesInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAgentVersions provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) ListAgentVersions(ctx context.Context, params *bedrockagent.ListAgentVersionsInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.ListAgentVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAgentVersions")
	}

	var r0 *bedrockagent.ListAgentVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListAgentVersionsInput, ...func(*bedrockagent.Options)) (*bedrockagent.ListAgentVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListAgentVersionsInput, ...func(*bedrockagent.Options)) *bedrockagent.ListAgentVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.ListAgentVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.ListAgentVersionsInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAgents provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) ListAgents(ctx context.Context, params *bedrockagent.ListAgentsInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.ListAgentsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAgents")
	}

	var r0 *bedrockagent.ListAgentsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListAgentsInput, ...func(*bedrockagent.Options)) (*bedrockagent.ListAgentsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListAgentsInput, ...func(*bedrockagent.Options)) *bedrockagent.ListAgentsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.ListAgentsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.ListAgentsInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDataSources provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) ListDataSources(ctx context.Context, params *bedrockagent.ListDataSourcesInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.ListDataSourcesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDataSources")
	}

	var r0 *bedrockagent.ListDataSourcesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListDataSourcesInput, ...func(*bedrockagent.Options)) (*bedrockagent.ListDataSourcesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListDataSourcesInput, ...func(*bedrockagent.Options)) *bedrockagent.ListDataSourcesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.ListDataSourcesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.ListDataSourcesInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListIngestionJobs provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) ListIngestionJobs(ctx context.Context, params *bedrockagent.ListIngestionJobsInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.ListIngestionJobsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListIngestionJobs")
	}

	var r0 *bedrockagent.ListIngestionJobsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListIngestionJobsInput, ...func(*bedrockagent.Options)) (*bedrockagent.ListIngestionJobsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListIngestionJobsInput, ...func(*bedrockagent.Options)) *bedrockagent.ListIngestionJobsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.ListIngestionJobsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.ListIngestionJobsInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListKnowledgeBases provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) ListKnowledgeBases(ctx context.Context, params *bedrockagent.ListKnowledgeBasesInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.ListKnowledgeBasesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListKnowledgeBases")
	}

	var r0 *bedrockagent.ListKnowledgeBasesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListKnowledgeBasesInput, ...func(*bedrockagent.Options)) (*bedrockagent.ListKnowledgeBasesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListKnowledgeBasesInput, ...func(*bedrockagent.Options)) *bedrockagent.ListKnowledgeBasesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.ListKnowledgeBasesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.ListKnowledgeBasesInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) ListTagsForResource(ctx context.Context, params *bedrockagent.ListTagsForResourceInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *bedrockagent.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListTagsForResourceInput, ...func(*bedrockagent.Options)) (*bedrockagent.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.ListTagsForResourceInput, ...func(*bedrockagent.Options)) *bedrockagent.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.ListTagsForResourceInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *BedrockagentClient) Options() bedrockagent.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 bedrockagent.Options
	if rf, ok := ret.Get(0).(func() bedrockagent.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bedrockagent.Options)
	}

	return r0
}

// PrepareAgent provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) PrepareAgent(ctx context.Context, params *bedrockagent.PrepareAgentInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.PrepareAgentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PrepareAgent")
	}

	var r0 *bedrockagent.PrepareAgentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.PrepareAgentInput, ...func(*bedrockagent.Options)) (*bedrockagent.PrepareAgentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.PrepareAgentInput, ...func(*bedrockagent.Options)) *bedrockagent.PrepareAgentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.PrepareAgentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.PrepareAgentInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartIngestionJob provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) StartIngestionJob(ctx context.Context, params *bedrockagent.StartIngestionJobInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.StartIngestionJobOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartIngestionJob")
	}

	var r0 *bedrockagent.StartIngestionJobOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.StartIngestionJobInput, ...func(*bedrockagent.Options)) (*bedrockagent.StartIngestionJobOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.StartIngestionJobInput, ...func(*bedrockagent.Options)) *bedrockagent.StartIngestionJobOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.StartIngestionJobOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.StartIngestionJobInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) TagResource(ctx context.Context, params *bedrockagent.TagResourceInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *bedrockagent.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.TagResourceInput, ...func(*bedrockagent.Options)) (*bedrockagent.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.TagResourceInput, ...func(*bedrockagent.Options)) *bedrockagent.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.TagResourceInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) UntagResource(ctx context.Context, params *bedrockagent.UntagResourceInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *bedrockagent.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.UntagResourceInput, ...func(*bedrockagent.Options)) (*bedrockagent.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.UntagResourceInput, ...func(*bedrockagent.Options)) *bedrockagent.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.UntagResourceInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAgent provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) UpdateAgent(ctx context.Context, params *bedrockagent.UpdateAgentInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.UpdateAgentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAgent")
	}

	var r0 *bedrockagent.UpdateAgentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.UpdateAgentInput, ...func(*bedrockagent.Options)) (*bedrockagent.UpdateAgentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.UpdateAgentInput, ...func(*bedrockagent.Options)) *bedrockagent.UpdateAgentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.UpdateAgentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.UpdateAgentInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAgentActionGroup provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) UpdateAgentActionGroup(ctx context.Context, params *bedrockagent.UpdateAgentActionGroupInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.UpdateAgentActionGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAgentActionGroup")
	}

	var r0 *bedrockagent.UpdateAgentActionGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.UpdateAgentActionGroupInput, ...func(*bedrockagent.Options)) (*bedrockagent.UpdateAgentActionGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.UpdateAgentActionGroupInput, ...func(*bedrockagent.Options)) *bedrockagent.UpdateAgentActionGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.UpdateAgentActionGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.UpdateAgentActionGroupInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAgentAlias provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) UpdateAgentAlias(ctx context.Context, params *bedrockagent.UpdateAgentAliasInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.UpdateAgentAliasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAgentAlias")
	}

	var r0 *bedrockagent.UpdateAgentAliasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.UpdateAgentAliasInput, ...func(*bedrockagent.Options)) (*bedrockagent.UpdateAgentAliasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.UpdateAgentAliasInput, ...func(*bedrockagent.Options)) *bedrockagent.UpdateAgentAliasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.UpdateAgentAliasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.UpdateAgentAliasInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAgentKnowledgeBase provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) UpdateAgentKnowledgeBase(ctx context.Context, params *bedrockagent.UpdateAgentKnowledgeBaseInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.UpdateAgentKnowledgeBaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAgentKnowledgeBase")
	}

	var r0 *bedrockagent.UpdateAgentKnowledgeBaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.UpdateAgentKnowledgeBaseInput, ...func(*bedrockagent.Options)) (*bedrockagent.UpdateAgentKnowledgeBaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.UpdateAgentKnowledgeBaseInput, ...func(*bedrockagent.Options)) *bedrockagent.UpdateAgentKnowledgeBaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.UpdateAgentKnowledgeBaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.UpdateAgentKnowledgeBaseInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateDataSource provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) UpdateDataSource(ctx context.Context, params *bedrockagent.UpdateDataSourceInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.UpdateDataSourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateDataSource")
	}

	var r0 *bedrockagent.UpdateDataSourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.UpdateDataSourceInput, ...func(*bedrockagent.Options)) (*bedrockagent.UpdateDataSourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.UpdateDataSourceInput, ...func(*bedrockagent.Options)) *bedrockagent.UpdateDataSourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.UpdateDataSourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.UpdateDataSourceInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateKnowledgeBase provides a mock function with given fields: ctx, params, optFns
func (_m *BedrockagentClient) UpdateKnowledgeBase(ctx context.Context, params *bedrockagent.UpdateKnowledgeBaseInput, optFns ...func(*bedrockagent.Options)) (*bedrockagent.UpdateKnowledgeBaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateKnowledgeBase")
	}

	var r0 *bedrockagent.UpdateKnowledgeBaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.UpdateKnowledgeBaseInput, ...func(*bedrockagent.Options)) (*bedrockagent.UpdateKnowledgeBaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bedrockagent.UpdateKnowledgeBaseInput, ...func(*bedrockagent.Options)) *bedrockagent.UpdateKnowledgeBaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bedrockagent.UpdateKnowledgeBaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bedrockagent.UpdateKnowledgeBaseInput, ...func(*bedrockagent.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewBedrockagentClient creates a new instance of BedrockagentClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewBedrockagentClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *BedrockagentClient {
	mock := &BedrockagentClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
