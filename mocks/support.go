// Code generated by mockery v2.42.1. DO NOT EDIT.

package mocks

import (
	context "context"

	mock "github.com/stretchr/testify/mock"

	support "github.com/aws/aws-sdk-go-v2/service/support"
)

// SupportClient is an autogenerated mock type for the SupportClient type
type SupportClient struct {
	mock.Mock
}

// AddAttachmentsToSet provides a mock function with given fields: ctx, params, optFns
func (_m *SupportClient) AddAttachmentsToSet(ctx context.Context, params *support.AddAttachmentsToSetInput, optFns ...func(*support.Options)) (*support.AddAttachmentsToSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddAttachmentsToSet")
	}

	var r0 *support.AddAttachmentsToSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *support.AddAttachmentsToSetInput, ...func(*support.Options)) (*support.AddAttachmentsToSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *support.AddAttachmentsToSetInput, ...func(*support.Options)) *support.AddAttachmentsToSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*support.AddAttachmentsToSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *support.AddAttachmentsToSetInput, ...func(*support.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddCommunicationToCase provides a mock function with given fields: ctx, params, optFns
func (_m *SupportClient) AddCommunicationToCase(ctx context.Context, params *support.AddCommunicationToCaseInput, optFns ...func(*support.Options)) (*support.AddCommunicationToCaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddCommunicationToCase")
	}

	var r0 *support.AddCommunicationToCaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *support.AddCommunicationToCaseInput, ...func(*support.Options)) (*support.AddCommunicationToCaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *support.AddCommunicationToCaseInput, ...func(*support.Options)) *support.AddCommunicationToCaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*support.AddCommunicationToCaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *support.AddCommunicationToCaseInput, ...func(*support.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCase provides a mock function with given fields: ctx, params, optFns
func (_m *SupportClient) CreateCase(ctx context.Context, params *support.CreateCaseInput, optFns ...func(*support.Options)) (*support.CreateCaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCase")
	}

	var r0 *support.CreateCaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *support.CreateCaseInput, ...func(*support.Options)) (*support.CreateCaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *support.CreateCaseInput, ...func(*support.Options)) *support.CreateCaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*support.CreateCaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *support.CreateCaseInput, ...func(*support.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAttachment provides a mock function with given fields: ctx, params, optFns
func (_m *SupportClient) DescribeAttachment(ctx context.Context, params *support.DescribeAttachmentInput, optFns ...func(*support.Options)) (*support.DescribeAttachmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeAttachment")
	}

	var r0 *support.DescribeAttachmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *support.DescribeAttachmentInput, ...func(*support.Options)) (*support.DescribeAttachmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *support.DescribeAttachmentInput, ...func(*support.Options)) *support.DescribeAttachmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*support.DescribeAttachmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *support.DescribeAttachmentInput, ...func(*support.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCases provides a mock function with given fields: ctx, params, optFns
func (_m *SupportClient) DescribeCases(ctx context.Context, params *support.DescribeCasesInput, optFns ...func(*support.Options)) (*support.DescribeCasesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCases")
	}

	var r0 *support.DescribeCasesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *support.DescribeCasesInput, ...func(*support.Options)) (*support.DescribeCasesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *support.DescribeCasesInput, ...func(*support.Options)) *support.DescribeCasesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*support.DescribeCasesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *support.DescribeCasesInput, ...func(*support.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCommunications provides a mock function with given fields: ctx, params, optFns
func (_m *SupportClient) DescribeCommunications(ctx context.Context, params *support.DescribeCommunicationsInput, optFns ...func(*support.Options)) (*support.DescribeCommunicationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCommunications")
	}

	var r0 *support.DescribeCommunicationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *support.DescribeCommunicationsInput, ...func(*support.Options)) (*support.DescribeCommunicationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *support.DescribeCommunicationsInput, ...func(*support.Options)) *support.DescribeCommunicationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*support.DescribeCommunicationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *support.DescribeCommunicationsInput, ...func(*support.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCreateCaseOptions provides a mock function with given fields: ctx, params, optFns
func (_m *SupportClient) DescribeCreateCaseOptions(ctx context.Context, params *support.DescribeCreateCaseOptionsInput, optFns ...func(*support.Options)) (*support.DescribeCreateCaseOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCreateCaseOptions")
	}

	var r0 *support.DescribeCreateCaseOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *support.DescribeCreateCaseOptionsInput, ...func(*support.Options)) (*support.DescribeCreateCaseOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *support.DescribeCreateCaseOptionsInput, ...func(*support.Options)) *support.DescribeCreateCaseOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*support.DescribeCreateCaseOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *support.DescribeCreateCaseOptionsInput, ...func(*support.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeServices provides a mock function with given fields: ctx, params, optFns
func (_m *SupportClient) DescribeServices(ctx context.Context, params *support.DescribeServicesInput, optFns ...func(*support.Options)) (*support.DescribeServicesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeServices")
	}

	var r0 *support.DescribeServicesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *support.DescribeServicesInput, ...func(*support.Options)) (*support.DescribeServicesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *support.DescribeServicesInput, ...func(*support.Options)) *support.DescribeServicesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*support.DescribeServicesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *support.DescribeServicesInput, ...func(*support.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSeverityLevels provides a mock function with given fields: ctx, params, optFns
func (_m *SupportClient) DescribeSeverityLevels(ctx context.Context, params *support.DescribeSeverityLevelsInput, optFns ...func(*support.Options)) (*support.DescribeSeverityLevelsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSeverityLevels")
	}

	var r0 *support.DescribeSeverityLevelsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *support.DescribeSeverityLevelsInput, ...func(*support.Options)) (*support.DescribeSeverityLevelsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *support.DescribeSeverityLevelsInput, ...func(*support.Options)) *support.DescribeSeverityLevelsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*support.DescribeSeverityLevelsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *support.DescribeSeverityLevelsInput, ...func(*support.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSupportedLanguages provides a mock function with given fields: ctx, params, optFns
func (_m *SupportClient) DescribeSupportedLanguages(ctx context.Context, params *support.DescribeSupportedLanguagesInput, optFns ...func(*support.Options)) (*support.DescribeSupportedLanguagesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSupportedLanguages")
	}

	var r0 *support.DescribeSupportedLanguagesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *support.DescribeSupportedLanguagesInput, ...func(*support.Options)) (*support.DescribeSupportedLanguagesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *support.DescribeSupportedLanguagesInput, ...func(*support.Options)) *support.DescribeSupportedLanguagesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*support.DescribeSupportedLanguagesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *support.DescribeSupportedLanguagesInput, ...func(*support.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTrustedAdvisorCheckRefreshStatuses provides a mock function with given fields: ctx, params, optFns
func (_m *SupportClient) DescribeTrustedAdvisorCheckRefreshStatuses(ctx context.Context, params *support.DescribeTrustedAdvisorCheckRefreshStatusesInput, optFns ...func(*support.Options)) (*support.DescribeTrustedAdvisorCheckRefreshStatusesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTrustedAdvisorCheckRefreshStatuses")
	}

	var r0 *support.DescribeTrustedAdvisorCheckRefreshStatusesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *support.DescribeTrustedAdvisorCheckRefreshStatusesInput, ...func(*support.Options)) (*support.DescribeTrustedAdvisorCheckRefreshStatusesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *support.DescribeTrustedAdvisorCheckRefreshStatusesInput, ...func(*support.Options)) *support.DescribeTrustedAdvisorCheckRefreshStatusesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*support.DescribeTrustedAdvisorCheckRefreshStatusesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *support.DescribeTrustedAdvisorCheckRefreshStatusesInput, ...func(*support.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTrustedAdvisorCheckResult provides a mock function with given fields: ctx, params, optFns
func (_m *SupportClient) DescribeTrustedAdvisorCheckResult(ctx context.Context, params *support.DescribeTrustedAdvisorCheckResultInput, optFns ...func(*support.Options)) (*support.DescribeTrustedAdvisorCheckResultOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTrustedAdvisorCheckResult")
	}

	var r0 *support.DescribeTrustedAdvisorCheckResultOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *support.DescribeTrustedAdvisorCheckResultInput, ...func(*support.Options)) (*support.DescribeTrustedAdvisorCheckResultOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *support.DescribeTrustedAdvisorCheckResultInput, ...func(*support.Options)) *support.DescribeTrustedAdvisorCheckResultOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*support.DescribeTrustedAdvisorCheckResultOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *support.DescribeTrustedAdvisorCheckResultInput, ...func(*support.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTrustedAdvisorCheckSummaries provides a mock function with given fields: ctx, params, optFns
func (_m *SupportClient) DescribeTrustedAdvisorCheckSummaries(ctx context.Context, params *support.DescribeTrustedAdvisorCheckSummariesInput, optFns ...func(*support.Options)) (*support.DescribeTrustedAdvisorCheckSummariesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTrustedAdvisorCheckSummaries")
	}

	var r0 *support.DescribeTrustedAdvisorCheckSummariesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *support.DescribeTrustedAdvisorCheckSummariesInput, ...func(*support.Options)) (*support.DescribeTrustedAdvisorCheckSummariesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *support.DescribeTrustedAdvisorCheckSummariesInput, ...func(*support.Options)) *support.DescribeTrustedAdvisorCheckSummariesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*support.DescribeTrustedAdvisorCheckSummariesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *support.DescribeTrustedAdvisorCheckSummariesInput, ...func(*support.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTrustedAdvisorChecks provides a mock function with given fields: ctx, params, optFns
func (_m *SupportClient) DescribeTrustedAdvisorChecks(ctx context.Context, params *support.DescribeTrustedAdvisorChecksInput, optFns ...func(*support.Options)) (*support.DescribeTrustedAdvisorChecksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTrustedAdvisorChecks")
	}

	var r0 *support.DescribeTrustedAdvisorChecksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *support.DescribeTrustedAdvisorChecksInput, ...func(*support.Options)) (*support.DescribeTrustedAdvisorChecksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *support.DescribeTrustedAdvisorChecksInput, ...func(*support.Options)) *support.DescribeTrustedAdvisorChecksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*support.DescribeTrustedAdvisorChecksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *support.DescribeTrustedAdvisorChecksInput, ...func(*support.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *SupportClient) Options() support.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 support.Options
	if rf, ok := ret.Get(0).(func() support.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(support.Options)
	}

	return r0
}

// RefreshTrustedAdvisorCheck provides a mock function with given fields: ctx, params, optFns
func (_m *SupportClient) RefreshTrustedAdvisorCheck(ctx context.Context, params *support.RefreshTrustedAdvisorCheckInput, optFns ...func(*support.Options)) (*support.RefreshTrustedAdvisorCheckOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RefreshTrustedAdvisorCheck")
	}

	var r0 *support.RefreshTrustedAdvisorCheckOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *support.RefreshTrustedAdvisorCheckInput, ...func(*support.Options)) (*support.RefreshTrustedAdvisorCheckOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *support.RefreshTrustedAdvisorCheckInput, ...func(*support.Options)) *support.RefreshTrustedAdvisorCheckOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*support.RefreshTrustedAdvisorCheckOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *support.RefreshTrustedAdvisorCheckInput, ...func(*support.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResolveCase provides a mock function with given fields: ctx, params, optFns
func (_m *SupportClient) ResolveCase(ctx context.Context, params *support.ResolveCaseInput, optFns ...func(*support.Options)) (*support.ResolveCaseOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResolveCase")
	}

	var r0 *support.ResolveCaseOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *support.ResolveCaseInput, ...func(*support.Options)) (*support.ResolveCaseOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *support.ResolveCaseInput, ...func(*support.Options)) *support.ResolveCaseOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*support.ResolveCaseOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *support.ResolveCaseInput, ...func(*support.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewSupportClient creates a new instance of SupportClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewSupportClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *SupportClient {
	mock := &SupportClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
